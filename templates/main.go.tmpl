// Code generated by sqlc-grpc (https://github.com/walterwanderley/sqlc-grpc).

package main

import (
	"context"
	"database/sql"
	_ "embed"
	"errors"
	"fmt"
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"runtime"
	"syscall"
	"time"

    "go.opentelemetry.io/otel/metric"
    "go.opentelemetry.io/otel/trace"
    "github.com/Enigmatic-Smile/go-common/coreservicefx"
	"github.com/Enigmatic-Smile/go-common/logger"
	"github.com/Enigmatic-Smile/go-common/types"
	"github.com/exaring/otelpgx"
	"github.com/flowchartsman/swaggerui"
	"github.com/JamesArthurHolland/ezenv"
	"github.com/XSAM/otelsql"
	semconv "go.opentelemetry.io/otel/semconv/v1.23.0"
	"go.uber.org/fx"
	// database driver
	_ "{{ .DatabaseImport}}"
	{{if .MigrationPath}}{{if eq .SqlPackage "pgx/v5"}}_ "github.com/jackc/pgx/v5/stdlib"{{end}}{{end}}

	{{range .Packages}}app_{{.Package}} "{{ .GoModule}}/{{.SrcPath}}"
	{{end}}	"{{ .GoModule}}/internal/server"
	"{{ .GoModule}}/internal/server/instrumentation"
)
{{if .Args}}//go:generate {{ .Args}}{{end}}

var (
	//go:embed api/apidocs.swagger.json
	openAPISpec []byte
)

type DbUrl string
type Port int
type EnableCors string

func NewDb(dbUrl DbUrl, tracerProvider trace.TracerProvider {{if ne .SqlPackage "pgx/v5"}}, meterProvider metric.MeterProvider{{end}}) ({{if eq .SqlPackage "pgx/v5"}}*pgxpool.Pool{{else}}*sql.DB{{end}}, error) {
    {{- if eq .SqlPackage "pgx/v5"}}
    dbCfg, err := pgxpool.ParseConfig(string(dbUrl))
    if err != nil {
        return nil, err
    }

    dbCfg.ConnConfig.Tracer = otelpgx.NewTracer(otelpgx.WithTracerProvider(tracerProvider))

    return pgxpool.NewWithConfig(context.Background(), dbCfg)
    {{- else}}
    db, err := otelsql.Open("{{ .DatabaseDriver}}", string(dbUrl), otelsql.WithAttributes(
        {{if eq .Database "mysql"}}semconv.DBSystemMySQL{{else if eq .Database "sqlite"}}semconv.DBSystemSqlite{{else}}semconv.DBSystemPostgreSQL{{end}},
    ))
    if err != nil {
        return nil, err
    }

    err = otelsql.RegisterDBStatsMetrics(db,
        otelsql.WithAttributes(
            {{if eq .Database "mysql"}}semconv.DBSystemMySQL{{else if eq .Database "sqlite"}}semconv.DBSystemSqlite{{else}}semconv.DBSystemPostgreSQL{{end}},
        ),
        otelsql.WithTracerProvider(tracerProvider),
        otelsql.WithMeterProvider(meterProvider),
    )
    if err != nil {
        return nil, err
    }

    return db, nil
    {{end}}
}

type Params struct {
    fx.In

    Logger *logger.Logger
    Db {{if eq .SqlPackage "pgx/v5"}}*pgxpool.Pool{{else}}*sql.DB{{end}}
    Port Port
    ServiceName types.ServiceName
    EnableCors EnableCors
    MeterProvider metric.MeterProvider
    TracerProvider trace.TracerProvider
}

type Result struct {
    fx.Out

    Service *Service
    Start coreservicefx.StartFunc
    Stop coreservicefx.StopFunc
}

type Service struct {
    db {{if eq .SqlPackage "pgx/v5"}}*pgxpool.Pool{{else}}*sql.DB{{end}}
    logger *logger.Logger
    srv *server.Server
    name string
}

func NewService(p Params) (Result, error) {
    enableCors, err := strconv.ParseBool(string(p.EnableCors))
    if err != nil {
        return Result{}, err
    }

    cfg := server.Config{
        ServiceName: string(p.ServiceName),
        Port: int(p.Port),
        EnableCors: enableCors,
    }
    srv := server.New(cfg, registerServer(p.Db, p.Logger), registerHandlers(), httpHandlers, p.MeterProvider, p.TracerProvider, p.Logger)

    svc := &Service{
        db: p.Db,
        logger: p.Logger,
        srv: srv,
        name: string(p.ServiceName),
    }

    return Result{
        Service: svc,
        Start: svc.Start,
        Stop: svc.Stop,
    }, nil
}

func (s *Service) Start(ctx context.Context) error {
    {{- if .MigrationPath}}{{if eq .SqlPackage "pgx/v5"}}
    dbMigration, err := sql.Open("pgx", dbURL)
    if err != nil {
        return err
    }
    err = ensureSchema(dbMigration)
    if err != nil { slog.Error("migration error", "error", err) }
    dbMigration.Close()
    {{- else}}
    if err := ensureSchema(db); err != nil { slog.Error("migration error", "error", err) }{{end}}{{- end}}

    go func() {
        err := s.srv.ListenAndServe()
        if err != nil && !errors.Is(err, http.ErrServerClosed) {
            s.logger.Error(ctx, "Server start error", zap.Error(err))
        }
    }()
    return nil
}

func (s *Service) Stop(ctx context.Context) error {
    s.srv.Shutdown(ctx)
    s.db.Close()
    return nil
}

func main() {
    diConfig := []fx.Option{
        coreservicefx.ModuleFromEnv,

        fx.Provide(
            ezenv.Provider[DbUrl],
            ezenv.Provider[Port],
            ezenv.Provider[EnableCors],

            NewService,
            NewDb,
        ),
    }

    fx.New(diConfig...).Run()
}

func httpHandlers(mux *http.ServeMux) {
	mux.HandleFunc("/liveness", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(200)
	})
	mux.Handle("/swagger/", http.StripPrefix("/swagger", swaggerui.Handler(openAPISpec)))
}